{
  "id": "test-template",
  "entities": [
    {
      "type": "directory",
      "path": "src",
      "children": [
        {
          "type": "file",
          "path": "src/Main.purs",
          "content": "module Main where\n\nimport Prelude\n\nimport Data.TemplateString as TemplateString\nimport Data.Tuple.Nested ((/\\))\nimport Effect (Effect)\nimport Effect.Console as Console\n\nmain :: Effect Unit\nmain = do\n  let templatedString = TemplateString.template \"Hello, ${name}!\" [ \"name\" /\\ \"you\" ]\n  Console.log templatedString\n"
        },
        {
          "type": "directory",
          "path": "src/Skapa",
          "children": [
            {
              "type": "file",
              "path": "src/Skapa/Templates.purs",
              "content": "module Skapa.Templates\n  ( instantiate\n  , pathToTemplate\n  , pathsToTemplate\n  ) where\n\nimport Prelude\n\nimport Data.Array as Array\nimport Data.Foldable (foldMap)\nimport Data.Maybe (Maybe(..))\nimport Data.TemplateString as TemplateString\nimport Data.Traversable (sequence, traverse)\nimport Data.Tuple (Tuple)\nimport Effect.Aff (Aff)\nimport Effect.Class (liftEffect)\nimport Node.Buffer as Buffer\nimport Node.Encoding as Encoding\nimport Node.FS.Aff as FileSystem\nimport Node.FS.Stats as Stats\nimport Skapa.Types (Entity(..), FileOutput(..), Template(..), TemplateDescription, TemplateId)\n\n-- | Instantiates a template with a set of variables so that it can be filled in.\ninstantiate :: Template -> Array (Tuple String String) -> Array FileOutput\ninstantiate (Template { entities }) variables =\n  foldMap (instantiateEntity variables) entities\n\n-- | Turns an array of paths into a template, reading all files for all paths.\npathsToTemplate :: TemplateId -> TemplateDescription -> Array String -> Aff (Maybe (Array Template))\npathsToTemplate id description paths = do\n  sequence <$> traverse (pathToTemplate id description) paths\n\n-- | Turns a path into a template, reading all files for the path if it's a directory or just the\n-- | file if it's a file.\npathToTemplate :: TemplateId -> TemplateDescription -> String -> Aff (Maybe Template)\npathToTemplate id description path =\n  map (\\entity -> Template { id, description, entities: [ entity ] }) <$> pathToEntity path\n\ninstantiateEntity :: Array (Tuple String String) -> Entity -> Array FileOutput\ninstantiateEntity variables (File { path, content }) =\n  { path, contents: TemplateString.template content variables } # FileOutput # Array.singleton\ninstantiateEntity variables (Directory { path, children }) =\n  foldMap (instantiateEntity variables) (map (prependPath path) children)\n\nprependPath :: String -> Entity -> Entity\nprependPath path (File { path: childPath, content }) =\n  File { path: path <> \"/\" <> childPath, content }\nprependPath path (Directory { path: childPath, children }) =\n  Directory { path: path <> \"/\" <> childPath, children }\n\npathToEntity :: String -> Aff (Maybe Entity)\npathToEntity path = do\n  stats <- FileSystem.stat path\n  if Stats.isDirectory stats then directoryToEntity path else fileToEntity path\n\ndirectoryToEntity :: String -> Aff (Maybe Entity)\ndirectoryToEntity path = do\n  children <- FileSystem.readdir path\n  entities <- traverse pathToEntity (map (\\p -> path <> \"/\" <> p) children)\n  { path, children: Array.catMaybes entities } # Directory # Just # pure\n\nfileToEntity :: String -> Aff (Maybe Entity)\nfileToEntity path = do\n  buffer <- FileSystem.readFile path\n  content <- buffer # Buffer.toString Encoding.UTF8 # liftEffect\n  { path, content } # File # Just # pure\n"
            },
            {
              "type": "file",
              "path": "src/Skapa/Types.purs",
              "content": "module Skapa.Types where\n\nimport Data.Eq (class Eq)\nimport Data.Function (($))\nimport Data.Generic.Rep (class Generic)\nimport Data.Newtype (class Newtype)\nimport Data.Ord (class Ord)\nimport Data.Semigroup ((<>))\nimport Data.Show (class Show, show)\nimport Data.Show.Generic (genericShow)\nimport Record as Record\nimport Simple.JSON (class WriteForeign, writeImpl)\n\nnewtype TemplateId = TemplateId String\n\nderive newtype instance eqTemplateId :: Eq TemplateId\nderive newtype instance ordTemplateId :: Ord TemplateId\nderive newtype instance writeForeignTemplateId :: WriteForeign TemplateId\nderive instance newtypeTemplateId :: Newtype TemplateId _\nderive instance genericTemplateId :: Generic TemplateId _\n\ninstance showTemplateId :: Show TemplateId where\n  show (TemplateId s) = \"TemplateId \" <> show s\n\nnewtype TemplateDescription = TemplateDescription String\n\nderive newtype instance eqTemplateDescription :: Eq TemplateDescription\nderive newtype instance ordTemplateDescription :: Ord TemplateDescription\nderive newtype instance writeForeignTemplateDescription :: WriteForeign TemplateDescription\nderive instance newtypeTemplateDescription :: Newtype TemplateDescription _\nderive instance genericTemplateDescription :: Generic TemplateDescription _\n\ninstance showTemplateDescription :: Show TemplateDescription where\n  show (TemplateDescription s) = \"TemplateDescription \" <> show s\n\nnewtype Template = Template\n  { id :: TemplateId\n  , description :: TemplateDescription\n  , entities :: Array Entity\n  }\n\nderive newtype instance eqTemplate :: Eq Template\nderive instance genericTemplate :: Generic Template _\nderive instance newtypeTemplate :: Newtype Template _\nderive newtype instance writeForeignTemplate :: WriteForeign Template\n\ninstance showTemplate :: Show Template where\n  show = genericShow\n\ndata Entity\n  = File { path :: String, content :: String }\n  | Directory { path :: String, children :: Array Entity }\n\nderive instance eqEntity :: Eq Entity\nderive instance genericEntity :: Generic Entity _\n\ninstance showEntity :: Show Entity where\n  show (File fileData) = \"File \" <> show fileData\n  show (Directory directoryData) = \"Directory \" <> show directoryData\n\ninstance writeForeignEntity :: WriteForeign Entity where\n  writeImpl (File d) = writeImpl $ d `Record.merge` { type: \"file\" }\n  writeImpl (Directory d) = writeImpl $ d `Record.merge` { type: \"directory\" }\n\nnewtype FileOutput = FileOutput\n  { path :: String\n  , contents :: String\n  }\n\nderive newtype instance eqFileOutput :: Eq FileOutput\nderive instance genericFileOutput :: Generic FileOutput _\nderive instance newtypeFileOutput :: Newtype FileOutput _\n\ninstance showFileOutput :: Show FileOutput where\n  show = genericShow\n\nnewtype Identifier = Identifier String\n\nderive newtype instance eqIdentifier :: Eq Identifier\nderive newtype instance ordIdentifier :: Ord Identifier\nderive instance genericIdentifier :: Generic Identifier _\nderive instance newtypeIdentifier :: Newtype Identifier _\n\ninstance showIdentifier :: Show Identifier where\n  show = genericShow\n"
            }
          ]
        }
      ]
    }
  ],
  "description": "Testing template"
}

